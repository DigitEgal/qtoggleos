#!/bin/bash

SYS_CONF="/etc/qtoggleserver.conf"
BOOT_CONF="/boot/qtoggleserver.conf"
CONF="/data/etc/qtoggleserver.conf"
LOG="/var/log/qtoggleserver.log"

PROG="/usr/bin/qtoggleserver"

SYS_DRIVERS="/usr/lib/qtoggleserver-drivers"
USER_DRIVERS="/data/qtoggleserver-drivers"

WATCH_TIMEOUT=60
WATCH_INTERVAL=10


test -n "${OS_VERSION}" || source /etc/init.d/base

prepare_conf ${CONF} ${SYS_CONF} ${BOOT_CONF}
test -f ${CONF} || exit 0


PORT=80
SCHEME="http"
PORT_RE="server[[:space:]]*=[[:space:]]*\{[^#\}p]*port[[:space:]]*=[[:space:]]*([0-9]+)"
CERT_RE="https[[:space:]]*=[[:space:]]*\{[^#\}c]*cert_file[[:space:]]*=[[:space:]]*([^#\} ]+)"
[[ $(<${CONF}) =~ ${PORT_RE} ]] && PORT=${BASH_REMATCH[1]}
[[ $(<${CONF}) =~ ${CERT_RE} ]] && SCHEME="https"


responsive() {
    curl -m 2 --insecure --head "${SCHEME}://127.0.0.1:${PORT}/frontend/static/qtoggleserver-bundle-dark.css" &>/dev/null && return 0 || return 1
}

watch() {
    count=0
    while true; do
        sleep ${WATCH_INTERVAL}
        if responsive; then
            count=0
        else
            if [[ $count -lt ${WATCH_TIMEOUT} ]]; then
                count=$(($count + ${WATCH_INTERVAL}))
            else
                logger -t qtoggleserver -s "not responding for ${WATCH_TIMEOUT} seconds, calling panic action"
                panic_action qtoggleserver
                break
            fi
        fi
    done
}

start() {
    msg_begin "Starting qtoggleserver"

    export PYTHONPATH=${PYTHONPATH}:${SYS_DRIVERS}/fwupdate:${SYS_DRIVERS}/persist:${SYS_DRIVERS}/ports
    export PYTHONPATH=${PYTHONPATH}:${USER_DRIVERS}/fwupdate:${USER_DRIVERS}/persist:${USER_DRIVERS}/ports

    ${PROG} -c ${CONF} &>> ${LOG} &

    count=0
    while true; do
        sleep 1

        if responsive; then
            break
        fi

        if [[ $count -gt ${WATCH_TIMEOUT} ]]; then
            msg_fail
            return 1
        fi

        count=$((count + 1))
    done

    watch &

    msg_done
}

stop() {
    msg_begin "Stopping qtoggleserver"
    killall -q $(basename ${PROG})
    test $? == 0 && msg_done || msg_fail
    
    sleep 1
    ps | grep $(basename $0) | grep -v $$ | grep -v grep | tr -s ' ' | sed -e 's/^\s//' | cut -d ' ' -f 1 | xargs -r kill
}

case "$1" in
    start)
        start
        ;;

    stop)
        stop
        ;;

    restart)
        stop
        start
        ;;

    *)
        echo "Usage: $0 {start|stop|restart}"
        exit 1
esac

exit $?
